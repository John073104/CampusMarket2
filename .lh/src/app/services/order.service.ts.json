{
    "sourceFile": "src/app/services/order.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1763384538018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763389651867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,19 +59,23 @@\n       createdAt: serverTimestamp(),\r\n       updatedAt: serverTimestamp()\r\n     };\r\n \r\n+    console.log('Creating order document...', newOrder);\r\n     const docRef = await addDoc(\r\n       collection(this.firestore, 'orders'), \r\n       newOrder\r\n     );\r\n+    console.log('Order document created:', docRef.id);\r\n     \r\n-    // Notify seller about new order\r\n-    await this.notificationService.notifyOrderPlaced(sellerId, docRef.id, customerName);\r\n+    // Run notifications and analytics in background (non-blocking)\r\n+    Promise.all([\r\n+      this.notificationService.notifyOrderPlaced(sellerId, docRef.id, customerName)\r\n+        .catch(err => console.error('Notification error:', err)),\r\n+      this.apiIntegrationService.trackOrderPlaced(docRef.id, totalPrice, customerId)\r\n+        .catch(err => console.error('Analytics error:', err))\r\n+    ]);\r\n     \r\n-    // Track order analytics\r\n-    await this.apiIntegrationService.trackOrderPlaced(docRef.id, totalPrice, customerId);\r\n-    \r\n     console.log('Order created successfully:', docRef.id);\r\n     return docRef.id;\r\n   }\r\n \r\n"
                },
                {
                    "date": 1763434788528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,20 +42,31 @@\n       phone: string;\r\n       address: string;\r\n       paymentMethod: string;\r\n     },\r\n-    pickupLocation?: string,\r\n+    paymentMethod?: 'cod' | 'gcash' | 'bank_transfer' | 'meet_and_pay',\r\n+    paymentProofImage?: string,\r\n     notes?: string\r\n   ): Promise<string> {\r\n+    // Determine payment status based on method\r\n+    const paymentStatus = (paymentMethod === 'gcash' || paymentMethod === 'bank_transfer') && paymentProofImage \r\n+      ? 'pending' \r\n+      : paymentMethod === 'cod' || paymentMethod === 'meet_and_pay' \r\n+      ? 'verified' \r\n+      : 'pending';\r\n+\r\n     const newOrder: Omit<Order, 'orderId'> = {\r\n       customerId,\r\n       customerName,\r\n       sellerId,\r\n       sellerName,\r\n       items,\r\n       totalPrice,\r\n       status: 'placed',\r\n-      pickupLocation: deliveryInfo?.address || pickupLocation,\r\n+      pickupLocation: deliveryInfo?.address,\r\n+      paymentMethod: paymentMethod || 'cod',\r\n+      paymentProofImage,\r\n+      paymentStatus,\r\n       notes,\r\n       createdAt: serverTimestamp(),\r\n       updatedAt: serverTimestamp()\r\n     };\r\n@@ -271,5 +282,44 @@\n         .filter(o => o.status === 'completed')\r\n         .reduce((sum, o) => sum + o.totalPrice, 0)\r\n     };\r\n   }\r\n+\r\n+  // Verify payment proof\r\n+  async verifyPayment(orderId: string): Promise<void> {\r\n+    await updateDoc(doc(this.firestore, 'orders', orderId), {\r\n+      paymentStatus: 'verified',\r\n+      paymentVerifiedAt: serverTimestamp(),\r\n+      updatedAt: serverTimestamp()\r\n+    });\r\n+\r\n+    // Get order details to notify customer\r\n+    const order = await this.getOrderById(orderId);\r\n+    if (order) {\r\n+      await this.notificationService.createNotification(\r\n+        order.customerId,\r\n+        'Payment Verified',\r\n+        `Your payment for order #${orderId.substring(0, 8)} has been verified. Your order will be processed soon.`,\r\n+        'order'\r\n+      );\r\n+    }\r\n+  }\r\n+\r\n+  // Reject payment proof\r\n+  async rejectPayment(orderId: string, reason: string): Promise<void> {\r\n+    await updateDoc(doc(this.firestore, 'orders', orderId), {\r\n+      paymentStatus: 'rejected',\r\n+      updatedAt: serverTimestamp()\r\n+    });\r\n+\r\n+    // Get order details to notify customer\r\n+    const order = await this.getOrderById(orderId);\r\n+    if (order) {\r\n+      await this.notificationService.createNotification(\r\n+        order.customerId,\r\n+        'Payment Verification Failed',\r\n+        `Payment proof for order #${orderId.substring(0, 8)} was rejected. Reason: ${reason}. Please upload a valid payment proof.`,\r\n+        'order'\r\n+      );\r\n+    }\r\n+  }\r\n }\r\n"
                },
                {
                    "date": 1763883618762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,5 +321,16 @@\n         'order'\r\n       );\r\n     }\r\n   }\r\n+\r\n+  // Update order details (customer can edit delivery info and notes)\r\n+  async updateOrderDetails(orderId: string, updates: {\r\n+    pickupLocation?: string;\r\n+    notes?: string;\r\n+  }): Promise<void> {\r\n+    await updateDoc(doc(this.firestore, 'orders', orderId), {\r\n+      ...updates,\r\n+      updatedAt: serverTimestamp()\r\n+    });\r\n+  }\r\n }\r\n"
                },
                {
                    "date": 1763883857782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,19 +132,45 @@\n   }\r\n \r\n   // Get orders by seller\r\n   async getOrdersBySeller(sellerId: string): Promise<Order[]> {\r\n-    const q = query(\r\n-      collection(this.firestore, 'orders'),\r\n-      where('sellerId', '==', sellerId),\r\n-      orderBy('createdAt', 'desc')\r\n-    );\r\n-    \r\n-    const snapshot = await getDocs(q);\r\n-    return snapshot.docs.map(doc => ({\r\n-      orderId: doc.id,\r\n-      ...doc.data()\r\n-    } as Order));\r\n+    try {\r\n+      const q = query(\r\n+        collection(this.firestore, 'orders'),\r\n+        where('sellerId', '==', sellerId),\r\n+        orderBy('createdAt', 'desc')\r\n+      );\r\n+      \r\n+      const snapshot = await getDocs(q);\r\n+      console.log('Seller orders found:', snapshot.size);\r\n+      return snapshot.docs.map(doc => ({\r\n+        orderId: doc.id,\r\n+        ...doc.data()\r\n+      } as Order));\r\n+    } catch (error: any) {\r\n+      console.warn('Composite index not available for seller orders, using fallback...', error);\r\n+      // Fallback: Query without orderBy\r\n+      const fallbackQuery = query(\r\n+        collection(this.firestore, 'orders'),\r\n+        where('sellerId', '==', sellerId)\r\n+      );\r\n+      \r\n+      const snapshot = await getDocs(fallbackQuery);\r\n+      const orders = snapshot.docs.map(doc => ({\r\n+        orderId: doc.id,\r\n+        ...doc.data()\r\n+      } as Order));\r\n+      \r\n+      // Sort manually by createdAt\r\n+      orders.sort((a, b) => {\r\n+        const aTime = a.createdAt?.seconds || 0;\r\n+        const bTime = b.createdAt?.seconds || 0;\r\n+        return bTime - aTime;\r\n+      });\r\n+      \r\n+      console.log('Seller orders (fallback):', orders.length);\r\n+      return orders;\r\n+    }\r\n   }\r\n \r\n   // Get all orders (Admin)\r\n   async getAllOrders(): Promise<Order[]> {\r\n"
                }
            ],
            "date": 1763384538018,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { \r\n  Firestore, \r\n  collection, \r\n  doc,\r\n  addDoc,\r\n  updateDoc,\r\n  getDoc,\r\n  getDocs,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  serverTimestamp,\r\n  Timestamp\r\n} from '@angular/fire/firestore';\r\nimport { Order, OrderItem, OrderStatus } from '../models/order.model';\r\nimport { Observable, from } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { NotificationService } from './notification.service';\r\nimport { ApiIntegrationService } from './api-integration.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class OrderService {\r\n  constructor(\r\n    private firestore: Firestore,\r\n    private notificationService: NotificationService,\r\n    private apiIntegrationService: ApiIntegrationService\r\n  ) {}\r\n\r\n  // Create new order\r\n  async createOrder(\r\n    customerId: string,\r\n    customerName: string,\r\n    sellerId: string,\r\n    sellerName: string,\r\n    items: OrderItem[],\r\n    totalPrice: number,\r\n    deliveryInfo?: {\r\n      name: string;\r\n      phone: string;\r\n      address: string;\r\n      paymentMethod: string;\r\n    },\r\n    pickupLocation?: string,\r\n    notes?: string\r\n  ): Promise<string> {\r\n    const newOrder: Omit<Order, 'orderId'> = {\r\n      customerId,\r\n      customerName,\r\n      sellerId,\r\n      sellerName,\r\n      items,\r\n      totalPrice,\r\n      status: 'placed',\r\n      pickupLocation: deliveryInfo?.address || pickupLocation,\r\n      notes,\r\n      createdAt: serverTimestamp(),\r\n      updatedAt: serverTimestamp()\r\n    };\r\n\r\n    const docRef = await addDoc(\r\n      collection(this.firestore, 'orders'), \r\n      newOrder\r\n    );\r\n    \r\n    // Notify seller about new order\r\n    await this.notificationService.notifyOrderPlaced(sellerId, docRef.id, customerName);\r\n    \r\n    // Track order analytics\r\n    await this.apiIntegrationService.trackOrderPlaced(docRef.id, totalPrice, customerId);\r\n    \r\n    console.log('Order created successfully:', docRef.id);\r\n    return docRef.id;\r\n  }\r\n\r\n  // Get orders by customer\r\n  async getOrdersByCustomer(customerId: string): Promise<Order[]> {\r\n    try {\r\n      const q = query(\r\n        collection(this.firestore, 'orders'),\r\n        where('customerId', '==', customerId),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      \r\n      const snapshot = await getDocs(q);\r\n      console.log('Customer orders found:', snapshot.size);\r\n      return snapshot.docs.map(doc => ({\r\n        orderId: doc.id,\r\n        ...doc.data()\r\n      } as Order));\r\n    } catch (error: any) {\r\n      console.warn('Composite index not available for customer orders, using fallback...', error);\r\n      // Fallback: Query without orderBy\r\n      const fallbackQuery = query(\r\n        collection(this.firestore, 'orders'),\r\n        where('customerId', '==', customerId)\r\n      );\r\n      \r\n      const snapshot = await getDocs(fallbackQuery);\r\n      const orders = snapshot.docs.map(doc => ({\r\n        orderId: doc.id,\r\n        ...doc.data()\r\n      } as Order));\r\n      \r\n      // Sort manually by createdAt\r\n      orders.sort((a, b) => {\r\n        const aTime = a.createdAt?.seconds || 0;\r\n        const bTime = b.createdAt?.seconds || 0;\r\n        return bTime - aTime;\r\n      });\r\n      \r\n      console.log('Customer orders (fallback):', orders.length);\r\n      return orders;\r\n    }\r\n  }\r\n\r\n  // Get orders by seller\r\n  async getOrdersBySeller(sellerId: string): Promise<Order[]> {\r\n    const q = query(\r\n      collection(this.firestore, 'orders'),\r\n      where('sellerId', '==', sellerId),\r\n      orderBy('createdAt', 'desc')\r\n    );\r\n    \r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map(doc => ({\r\n      orderId: doc.id,\r\n      ...doc.data()\r\n    } as Order));\r\n  }\r\n\r\n  // Get all orders (Admin)\r\n  async getAllOrders(): Promise<Order[]> {\r\n    const q = query(\r\n      collection(this.firestore, 'orders'),\r\n      orderBy('createdAt', 'desc')\r\n    );\r\n    \r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map(doc => ({\r\n      orderId: doc.id,\r\n      ...doc.data()\r\n    } as Order));\r\n  }\r\n\r\n  // Get order by ID\r\n  async getOrderById(orderId: string): Promise<Order | null> {\r\n    const orderDoc = await getDoc(doc(this.firestore, 'orders', orderId));\r\n    return orderDoc.exists() ? {\r\n      orderId: orderDoc.id,\r\n      ...orderDoc.data()\r\n    } as Order : null;\r\n  }\r\n\r\n  // Update order status\r\n  async updateOrderStatus(\r\n    orderId: string, \r\n    status: OrderStatus\r\n  ): Promise<void> {\r\n    // Get order details first\r\n    const order = await this.getOrderById(orderId);\r\n    \r\n    await updateDoc(doc(this.firestore, 'orders', orderId), {\r\n      status,\r\n      updatedAt: serverTimestamp()\r\n    });\r\n\r\n    // Notify customer about status change\r\n    if (order) {\r\n      await this.notificationService.notifyOrderStatusChanged(\r\n        order.customerId,\r\n        orderId,\r\n        status\r\n      );\r\n\r\n      // Decrease stock when order is completed\r\n      if (status === 'completed') {\r\n        await this.decreaseProductStock(order.items);\r\n      }\r\n\r\n      // Send SMS for important status changes\r\n      if (status === 'ready_for_pickup' && order.pickupLocation) {\r\n        // TODO: Get customer phone number from user service\r\n        // await this.apiIntegrationService.sendOrderReadySMS(customerPhone, orderId, order.pickupLocation);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Decrease product stock after successful delivery\r\n  private async decreaseProductStock(items: OrderItem[]): Promise<void> {\r\n    try {\r\n      const updatePromises = items.map(async (item) => {\r\n        const productRef = doc(this.firestore, 'products', item.productId);\r\n        const productDoc = await getDoc(productRef);\r\n        \r\n        if (productDoc.exists()) {\r\n          const currentStock = productDoc.data()['stock'] || 0;\r\n          const newStock = Math.max(0, currentStock - item.quantity);\r\n          \r\n          await updateDoc(productRef, {\r\n            stock: newStock,\r\n            updatedAt: serverTimestamp()\r\n          });\r\n          \r\n          console.log(`Stock updated for ${item.productName}: ${currentStock} -> ${newStock}`);\r\n        }\r\n      });\r\n\r\n      await Promise.all(updatePromises);\r\n    } catch (error) {\r\n      console.error('Error decreasing product stock:', error);\r\n      // Don't throw error to prevent order status update from failing\r\n    }\r\n  }\r\n\r\n  // Cancel order\r\n  async cancelOrder(orderId: string): Promise<void> {\r\n    await this.updateOrderStatus(orderId, 'cancelled');\r\n  }\r\n\r\n  // Get order statistics for seller\r\n  async getSellerStats(sellerId: string): Promise<{\r\n    totalOrders: number;\r\n    totalRevenue: number;\r\n    pendingOrders: number;\r\n    completedOrders: number;\r\n  }> {\r\n    const orders = await this.getOrdersBySeller(sellerId);\r\n    \r\n    return {\r\n      totalOrders: orders.length,\r\n      totalRevenue: orders\r\n        .filter(o => o.status === 'completed')\r\n        .reduce((sum, o) => sum + o.totalPrice, 0),\r\n      pendingOrders: orders.filter(o => \r\n        ['placed', 'confirmed', 'ready_for_pickup'].includes(o.status)\r\n      ).length,\r\n      completedOrders: orders.filter(o => o.status === 'completed').length\r\n    };\r\n  }\r\n\r\n  // Get platform statistics (Admin)\r\n  async getPlatformStats(): Promise<{\r\n    totalOrders: number;\r\n    totalRevenue: number;\r\n    ordersToday: number;\r\n    revenueToday: number;\r\n  }> {\r\n    const orders = await this.getAllOrders();\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    \r\n    const ordersToday = orders.filter(o => {\r\n      const orderDate = (o.createdAt as Timestamp).toDate();\r\n      return orderDate >= today;\r\n    });\r\n\r\n    return {\r\n      totalOrders: orders.length,\r\n      totalRevenue: orders\r\n        .filter(o => o.status === 'completed')\r\n        .reduce((sum, o) => sum + o.totalPrice, 0),\r\n      ordersToday: ordersToday.length,\r\n      revenueToday: ordersToday\r\n        .filter(o => o.status === 'completed')\r\n        .reduce((sum, o) => sum + o.totalPrice, 0)\r\n    };\r\n  }\r\n}\r\n"
        }
    ]
}