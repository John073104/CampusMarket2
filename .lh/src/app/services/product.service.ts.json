{
    "sourceFile": "src/app/services/product.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1763386695399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1763386695399,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { \r\n  Firestore, \r\n  collection, \r\n  doc,\r\n  addDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  getDoc,\r\n  getDocs,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  serverTimestamp \r\n} from '@angular/fire/firestore';\r\nimport { Product } from '../models/product.model';\r\nimport { Observable, from } from 'rxjs';\r\nimport { NotificationService } from './notification.service';\r\nimport { UserService } from './user.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ProductService {\r\n  constructor(\r\n    private firestore: Firestore,\r\n    private notificationService: NotificationService,\r\n    private userService: UserService\r\n  ) {}\r\n\r\n  // Create new product - OPTIMIZED for speed\r\n  async createProduct(\r\n    product: Omit<Product, 'productId' | 'createdAt' | 'updatedAt'>,\r\n    imageFiles: File[]\r\n  ): Promise<string> {\r\n    try {\r\n      console.log('Starting fast product creation...', product.title);\r\n      \r\n      // Process images in parallel for speed\r\n      const imageUrls = await this.uploadProductImages(product.sellerId, imageFiles);\r\n\r\n      const newProduct: any = {\r\n        ...product,\r\n        images: imageUrls,\r\n        approved: false,\r\n        createdAt: serverTimestamp(),\r\n        updatedAt: serverTimestamp()\r\n      };\r\n\r\n      // Save to Firestore immediately (don't wait for notifications)\r\n      const docRef = await addDoc(\r\n        collection(this.firestore, 'products'), \r\n        newProduct\r\n      );\r\n      \r\n      console.log('Product saved with ID:', docRef.id);\r\n      \r\n      // Notify admins in background (don't wait)\r\n      this.notifyAdminsAboutNewProduct(product.title, product.sellerName)\r\n        .catch(err => console.error('Notification failed (non-blocking):', err));\r\n      \r\n      return docRef.id;\r\n    } catch (error: any) {\r\n      console.error('Error in createProduct:', error);\r\n      throw new Error(error.message || 'Failed to create product');\r\n    }\r\n  }\r\n\r\n  // Notify all admin users about new product\r\n  private async notifyAdminsAboutNewProduct(productTitle: string, sellerName: string): Promise<void> {\r\n    try {\r\n      const admins = await this.userService.getAdminUsers();\r\n      const notifyPromises = admins.map(admin =>\r\n        this.notificationService.createNotification(\r\n          admin.userId,\r\n          'New Product Pending Review',\r\n          `${sellerName} submitted \"${productTitle}\" for approval`,\r\n          'product'\r\n        )\r\n      );\r\n      await Promise.all(notifyPromises);\r\n    } catch (error) {\r\n      console.error('Error notifying admins:', error);\r\n    }\r\n  }\r\n\r\n  // Convert images to base64 - OPTIMIZED for speed\r\n  private async uploadProductImages(\r\n    sellerId: string, \r\n    files: File[]\r\n  ): Promise<string[]> {\r\n    console.log(`Fast converting ${files.length} images...`);\r\n    const startTime = Date.now();\r\n    \r\n    // Process all images in parallel for maximum speed\r\n    const results = await Promise.all(\r\n      files.map(file => this.fileToBase64(file))\r\n    );\r\n    \r\n    const duration = Date.now() - startTime;\r\n    console.log(`Images converted in ${duration}ms (${(duration / files.length).toFixed(0)}ms per image)`);\r\n    return results;\r\n  }\r\n\r\n  // Convert File to base64 string - OPTIMIZED\r\n  private fileToBase64(file: File): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => resolve(reader.result as string);\r\n      reader.onerror = () => reject(new Error('Failed to read: ' + file.name));\r\n      reader.readAsDataURL(file);\r\n    });\r\n  }\r\n\r\n  // Get all products (Admin)\r\n  async getAllProducts(): Promise<Product[]> {\r\n    const q = query(\r\n      collection(this.firestore, 'products'),\r\n      orderBy('createdAt', 'desc')\r\n    );\r\n    \r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map(doc => ({\r\n      productId: doc.id,\r\n      ...doc.data()\r\n    } as Product));\r\n  }\r\n\r\n  // Get approved products (for customers)\r\n  async getApprovedProducts(): Promise<Product[]> {\r\n    try {\r\n      console.log('Fetching approved products with composite index...');\r\n      const q = query(\r\n        collection(this.firestore, 'products'),\r\n        where('approved', '==', true),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      \r\n      const snapshot = await getDocs(q);\r\n      console.log('Found approved products:', snapshot.docs.length);\r\n      return snapshot.docs.map(doc => ({\r\n        productId: doc.id,\r\n        ...doc.data()\r\n      } as Product));\r\n    } catch (error: any) {\r\n      console.warn('Composite index not available, using fallback query...', error);\r\n      \r\n      // Fallback: Query without orderBy if index doesn't exist\r\n      const fallbackQuery = query(\r\n        collection(this.firestore, 'products'),\r\n        where('approved', '==', true)\r\n      );\r\n      \r\n      const snapshot = await getDocs(fallbackQuery);\r\n      const products = snapshot.docs.map(doc => ({\r\n        productId: doc.id,\r\n        ...doc.data()\r\n      } as Product));\r\n      \r\n      // Sort manually by createdAt\r\n      products.sort((a, b) => {\r\n        const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;\r\n        const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;\r\n        return dateB - dateA; // Descending order (newest first)\r\n      });\r\n      \r\n      console.log('Fallback query found products:', products.length);\r\n      return products;\r\n    }\r\n  }\r\n\r\n  // Get products by seller\r\n  async getProductsBySeller(sellerId: string): Promise<Product[]> {\r\n    try {\r\n      const q = query(\r\n        collection(this.firestore, 'products'),\r\n        where('sellerId', '==', sellerId),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      \r\n      const snapshot = await getDocs(q);\r\n      console.log(`Seller products count for ${sellerId}:`, snapshot.size);\r\n      return snapshot.docs.map(doc => ({\r\n        productId: doc.id,\r\n        ...doc.data()\r\n      } as Product));\r\n    } catch (error: any) {\r\n      // Fallback: Query without orderBy if composite index doesn't exist\r\n      console.warn('Composite index not available for seller products, using fallback...', error);\r\n      \r\n      const fallbackQuery = query(\r\n        collection(this.firestore, 'products'),\r\n        where('sellerId', '==', sellerId)\r\n      );\r\n      \r\n      const snapshot = await getDocs(fallbackQuery);\r\n      console.log(`Fallback query - Seller products count for ${sellerId}:`, snapshot.size);\r\n      \r\n      const products = snapshot.docs.map(doc => ({\r\n        productId: doc.id,\r\n        ...doc.data()\r\n      } as Product));\r\n      \r\n      // Sort manually by createdAt\r\n      products.sort((a, b) => {\r\n        const aTime = a.createdAt?.seconds || 0;\r\n        const bTime = b.createdAt?.seconds || 0;\r\n        return bTime - aTime; // Descending order (newest first)\r\n      });\r\n      \r\n      console.log('Seller products (sorted):', products);\r\n      return products;\r\n    }\r\n  }\r\n\r\n  // Get pending products (Admin)\r\n  async getPendingProducts(): Promise<Product[]> {\r\n    try {\r\n      // Try with orderBy first\r\n      const q = query(\r\n        collection(this.firestore, 'products'),\r\n        where('approved', '==', false),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      \r\n      const snapshot = await getDocs(q);\r\n      console.log('Pending products count:', snapshot.size);\r\n      const products = snapshot.docs.map(doc => ({\r\n        productId: doc.id,\r\n        ...doc.data()\r\n      } as Product));\r\n      console.log('Pending products:', products);\r\n      return products;\r\n    } catch (error: any) {\r\n      // If composite index error, try without orderBy\r\n      if (error.code === 'failed-precondition' || error.message?.includes('index')) {\r\n        console.warn('Using query without orderBy due to missing index');\r\n        const q = query(\r\n          collection(this.firestore, 'products'),\r\n          where('approved', '==', false)\r\n        );\r\n        \r\n        const snapshot = await getDocs(q);\r\n        console.log('Pending products count (no orderBy):', snapshot.size);\r\n        const products = snapshot.docs.map(doc => ({\r\n          productId: doc.id,\r\n          ...doc.data()\r\n        } as Product));\r\n        \r\n        // Sort manually by createdAt\r\n        products.sort((a, b) => {\r\n          const aTime = a.createdAt?.seconds || 0;\r\n          const bTime = b.createdAt?.seconds || 0;\r\n          return bTime - aTime;\r\n        });\r\n        \r\n        console.log('Pending products (sorted):', products);\r\n        return products;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Approve product (Admin)\r\n  async approveProduct(productId: string): Promise<void> {\r\n    // Get product details first\r\n    const product = await this.getProductById(productId);\r\n    \r\n    await updateDoc(doc(this.firestore, 'products', productId), {\r\n      approved: true,\r\n      updatedAt: serverTimestamp()\r\n    });\r\n\r\n    // Notify seller about approval\r\n    if (product) {\r\n      await this.notificationService.notifyProductApproved(\r\n        product.sellerId,\r\n        productId,\r\n        product.title\r\n      );\r\n    }\r\n  }\r\n\r\n  // Update product\r\n  async updateProduct(\r\n    productId: string,\r\n    updates: Partial<Product>\r\n  ): Promise<void> {\r\n    await updateDoc(doc(this.firestore, 'products', productId), {\r\n      ...updates,\r\n      updatedAt: serverTimestamp()\r\n    });\r\n  }\r\n\r\n  // Delete product\r\n  async deleteProduct(productId: string): Promise<void> {\r\n    // TODO: Delete associated images from storage\r\n    await deleteDoc(doc(this.firestore, 'products', productId));\r\n  }\r\n\r\n  // Get product by ID\r\n  async getProductById(productId: string): Promise<Product | null> {\r\n    const productDoc = await getDoc(doc(this.firestore, 'products', productId));\r\n    return productDoc.exists() ? {\r\n      productId: productDoc.id,\r\n      ...productDoc.data()\r\n    } as Product : null;\r\n  }\r\n\r\n  // Search products\r\n  async searchProducts(searchTerm: string): Promise<Product[]> {\r\n    const allProducts = await this.getApprovedProducts();\r\n    return allProducts.filter(product => \r\n      product.title.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n      product.description.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }\r\n\r\n  // Filter products by category\r\n  async filterByCategory(category: string): Promise<Product[]> {\r\n    const q = query(\r\n      collection(this.firestore, 'products'),\r\n      where('approved', '==', true),\r\n      where('category', '==', category)\r\n    );\r\n    \r\n    const snapshot = await getDocs(q);\r\n    return snapshot.docs.map(doc => ({\r\n      productId: doc.id,\r\n      ...doc.data()\r\n    } as Product));\r\n  }\r\n}"
        }
    ]
}