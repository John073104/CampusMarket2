{
    "sourceFile": "src/app/services/chat.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1763384538017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763384827106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,15 +107,17 @@\n \r\n   // Get messages for a chat (real-time)\r\n   getMessages(chatId: string): Observable<Message[]> {\r\n     return new Observable(observer => {\r\n+      let unsubscribe: (() => void) | undefined;\r\n+\r\n       try {\r\n         const q = query(\r\n           collection(this.firestore, 'chats', chatId, 'messages'),\r\n           orderBy('timestamp', 'asc')\r\n         );\r\n \r\n-        const unsubscribe = onSnapshot(q, \r\n+        unsubscribe = onSnapshot(q, \r\n           (snapshot) => {\r\n             const messages = snapshot.docs.map(doc => ({\r\n               messageId: doc.id,\r\n               ...doc.data()\r\n@@ -126,9 +128,9 @@\n             console.warn('Messages orderBy failed, using fallback...', error);\r\n             // Fallback without orderBy\r\n             const fallbackQuery = collection(this.firestore, 'chats', chatId, 'messages');\r\n             \r\n-            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n+            unsubscribe = onSnapshot(fallbackQuery, (snapshot) => {\r\n               const messages = snapshot.docs.map(doc => ({\r\n                 messageId: doc.id,\r\n                 ...doc.data()\r\n               } as Message));\r\n@@ -141,32 +143,36 @@\n               });\r\n               \r\n               observer.next(messages);\r\n             });\r\n-\r\n-            return () => unsubscribeFallback();\r\n           }\r\n         );\r\n-\r\n-        return () => unsubscribe();\r\n       } catch (error) {\r\n         console.error('Error setting up messages listener:', error);\r\n         observer.error(error);\r\n       }\r\n+\r\n+      return () => {\r\n+        if (unsubscribe) {\r\n+          unsubscribe();\r\n+        }\r\n+      };\r\n     });\r\n   }\r\n \r\n   // Get user chats (real-time)\r\n   getUserChats(userId: string): Observable<Chat[]> {\r\n     return new Observable(observer => {\r\n+      let unsubscribe: (() => void) | undefined;\r\n+\r\n       try {\r\n         const q = query(\r\n           collection(this.firestore, 'chats'),\r\n           where('participantIds', 'array-contains', userId),\r\n           orderBy('lastMessageTime', 'desc')\r\n         );\r\n \r\n-        const unsubscribe = onSnapshot(q, \r\n+        unsubscribe = onSnapshot(q, \r\n           (snapshot) => {\r\n             const chats = snapshot.docs.map(doc => ({\r\n               chatId: doc.id,\r\n               ...doc.data()\r\n@@ -181,9 +187,9 @@\n               collection(this.firestore, 'chats'),\r\n               where('participantIds', 'array-contains', userId)\r\n             );\r\n \r\n-            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n+            unsubscribe = onSnapshot(fallbackQuery, (snapshot) => {\r\n               const chats = snapshot.docs.map(doc => ({\r\n                 chatId: doc.id,\r\n                 ...doc.data()\r\n               } as Chat));\r\n@@ -197,18 +203,20 @@\n               \r\n               console.log('Loaded chats (fallback):', chats.length);\r\n               observer.next(chats);\r\n             });\r\n-\r\n-            return () => unsubscribeFallback();\r\n           }\r\n         );\r\n-\r\n-        return () => unsubscribe();\r\n       } catch (error) {\r\n         console.error('Error setting up chat listener:', error);\r\n         observer.error(error);\r\n       }\r\n+\r\n+      return () => {\r\n+        if (unsubscribe) {\r\n+          unsubscribe();\r\n+        }\r\n+      };\r\n     });\r\n   }\r\n \r\n   // Mark messages as read\r\n"
                },
                {
                    "date": 1763386695464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,57 +158,64 @@\n       };\r\n     });\r\n   }\r\n \r\n-  // Get user chats (real-time)\r\n+  // Get user chats (real-time) - OPTIMIZED with fast fallback\r\n   getUserChats(userId: string): Observable<Chat[]> {\r\n     return new Observable(observer => {\r\n       let unsubscribe: (() => void) | undefined;\r\n+      let hasEmitted = false;\r\n \r\n       try {\r\n+        console.log('Setting up chat listener for user:', userId);\r\n+        \r\n+        // Use simple query without orderBy for faster initial load\r\n         const q = query(\r\n           collection(this.firestore, 'chats'),\r\n-          where('participantIds', 'array-contains', userId),\r\n-          orderBy('lastMessageTime', 'desc')\r\n+          where('participantIds', 'array-contains', userId)\r\n         );\r\n \r\n         unsubscribe = onSnapshot(q, \r\n           (snapshot) => {\r\n+            hasEmitted = true;\r\n             const chats = snapshot.docs.map(doc => ({\r\n               chatId: doc.id,\r\n               ...doc.data()\r\n             } as Chat));\r\n-            console.log('Loaded chats:', chats.length);\r\n+            \r\n+            // Sort manually by lastMessageTime\r\n+            chats.sort((a, b) => {\r\n+              const aTime = a.lastMessageTime?.seconds || 0;\r\n+              const bTime = b.lastMessageTime?.seconds || 0;\r\n+              return bTime - aTime;\r\n+            });\r\n+            \r\n+            console.log('Chats loaded:', chats.length);\r\n             observer.next(chats);\r\n           },\r\n           (error) => {\r\n-            console.warn('Composite index not available, using fallback...', error);\r\n-            // Fallback: Query without orderBy\r\n-            const fallbackQuery = query(\r\n-              collection(this.firestore, 'chats'),\r\n-              where('participantIds', 'array-contains', userId)\r\n-            );\r\n-\r\n-            unsubscribe = onSnapshot(fallbackQuery, (snapshot) => {\r\n-              const chats = snapshot.docs.map(doc => ({\r\n-                chatId: doc.id,\r\n-                ...doc.data()\r\n-              } as Chat));\r\n-              \r\n-              // Sort manually by lastMessageTime\r\n-              chats.sort((a, b) => {\r\n-                const aTime = a.lastMessageTime?.seconds || 0;\r\n-                const bTime = b.lastMessageTime?.seconds || 0;\r\n-                return bTime - aTime;\r\n-              });\r\n-              \r\n-              console.log('Loaded chats (fallback):', chats.length);\r\n-              observer.next(chats);\r\n-            });\r\n+            console.error('Chat snapshot error:', error);\r\n+            if (!hasEmitted) {\r\n+              // Emit empty array on first error to prevent infinite loading\r\n+              observer.next([]);\r\n+              hasEmitted = true;\r\n+            }\r\n+            observer.error(error);\r\n           }\r\n         );\r\n+        \r\n+        // Emit empty array immediately if no data after 3 seconds\r\n+        setTimeout(() => {\r\n+          if (!hasEmitted) {\r\n+            console.log('No chats loaded after 3s, emitting empty array');\r\n+            observer.next([]);\r\n+            hasEmitted = true;\r\n+          }\r\n+        }, 3000);\r\n+        \r\n       } catch (error) {\r\n         console.error('Error setting up chat listener:', error);\r\n+        observer.next([]); // Emit empty array instead of error\r\n         observer.error(error);\r\n       }\r\n \r\n       return () => {\r\n"
                },
                {
                    "date": 1763606933041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,15 +15,16 @@\n   increment,\r\n   arrayUnion\r\n } from '@angular/fire/firestore';\r\n import { Chat, Message } from '../models/chat.model';\r\n+import { NotificationService } from './notification.service';\r\n import { Observable, BehaviorSubject } from 'rxjs';\r\n \r\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n export class ChatService {\r\n-  constructor(private firestore: Firestore) {}\r\n+  constructor(private firestore: Firestore, private notificationService: NotificationService) {}\r\n \r\n   // Create or get existing chat between two users\r\n   async getOrCreateChat(\r\n     userId1: string,\r\n@@ -102,8 +103,14 @@\n       lastMessage: text,\r\n       lastMessageTime: serverTimestamp(),\r\n       [`unreadCount.${otherParticipantId}`]: increment(1)\r\n     });\r\n+\r\n+    // Send in-app notification to other participant (non-blocking)\r\n+    if (otherParticipantId) {\r\n+      this.notificationService.notifyNewMessage(otherParticipantId, senderName, chatId)\r\n+        .catch(err => console.error('Failed to send chat notification:', err));\r\n+    }\r\n   }\r\n \r\n   // Get messages for a chat (real-time)\r\n   getMessages(chatId: string): Observable<Message[]> {\r\n"
                },
                {
                    "date": 1763884001020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,43 +32,63 @@\n     userId2: string,\r\n     userName2: string,\r\n     orderId?: string\r\n   ): Promise<string> {\r\n-    // Check if chat already exists\r\n-    const q = query(\r\n-      collection(this.firestore, 'chats'),\r\n-      where('participantIds', 'array-contains', userId1)\r\n-    );\r\n-    \r\n-    const snapshot = await getDocs(q);\r\n-    const existingChat = snapshot.docs.find(doc => {\r\n-      const chat = doc.data() as Chat;\r\n-      return chat.participantIds.includes(userId2) && \r\n-             (!orderId || chat.orderId === orderId);\r\n-    });\r\n+    try {\r\n+      console.log('getOrCreateChat called with:', { userId1, userName1, userId2, userName2, orderId });\r\n+      \r\n+      // Validate inputs\r\n+      if (!userId1 || !userId2) {\r\n+        throw new Error('User IDs are required');\r\n+      }\r\n+      if (!userName1 || !userName2) {\r\n+        throw new Error('User names are required');\r\n+      }\r\n \r\n-    if (existingChat) {\r\n-      return existingChat.id;\r\n-    }\r\n+      // Check if chat already exists\r\n+      const q = query(\r\n+        collection(this.firestore, 'chats'),\r\n+        where('participantIds', 'array-contains', userId1)\r\n+      );\r\n+      \r\n+      const snapshot = await getDocs(q);\r\n+      console.log('Found existing chats:', snapshot.size);\r\n+      \r\n+      const existingChat = snapshot.docs.find(doc => {\r\n+        const chat = doc.data() as Chat;\r\n+        return chat.participantIds.includes(userId2) && \r\n+               (!orderId || chat.orderId === orderId);\r\n+      });\r\n \r\n-    // Create new chat\r\n-    const newChat: Omit<Chat, 'chatId'> = {\r\n-      participantIds: [userId1, userId2],\r\n-      participantNames: {\r\n-        [userId1]: userName1,\r\n-        [userId2]: userName2\r\n-      },\r\n-      orderId,\r\n-      lastMessage: '',\r\n-      lastMessageTime: serverTimestamp(),\r\n-      unreadCount: {\r\n-        [userId1]: 0,\r\n-        [userId2]: 0\r\n+      if (existingChat) {\r\n+        console.log('Returning existing chat:', existingChat.id);\r\n+        return existingChat.id;\r\n       }\r\n-    };\r\n \r\n-    const docRef = await addDoc(collection(this.firestore, 'chats'), newChat);\r\n-    return docRef.id;\r\n+      // Create new chat\r\n+      console.log('Creating new chat...');\r\n+      const newChat: Omit<Chat, 'chatId'> = {\r\n+        participantIds: [userId1, userId2],\r\n+        participantNames: {\r\n+          [userId1]: userName1,\r\n+          [userId2]: userName2\r\n+        },\r\n+        orderId,\r\n+        lastMessage: '',\r\n+        lastMessageTime: serverTimestamp(),\r\n+        unreadCount: {\r\n+          [userId1]: 0,\r\n+          [userId2]: 0\r\n+        }\r\n+      };\r\n+\r\n+      const docRef = await addDoc(collection(this.firestore, 'chats'), newChat);\r\n+      console.log('New chat created:', docRef.id);\r\n+      return docRef.id;\r\n+    } catch (error) {\r\n+      console.error('Error in getOrCreateChat:', error);\r\n+      throw error;\r\n+    }\r\n   }\r\n \r\n   // Send message\r\n   async sendMessage(\r\n"
                },
                {
                    "date": 1763884121936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,23 +65,27 @@\n       }\r\n \r\n       // Create new chat\r\n       console.log('Creating new chat...');\r\n-      const newChat: Omit<Chat, 'chatId'> = {\r\n+      const newChat: any = {\r\n         participantIds: [userId1, userId2],\r\n         participantNames: {\r\n           [userId1]: userName1,\r\n           [userId2]: userName2\r\n         },\r\n-        orderId,\r\n         lastMessage: '',\r\n         lastMessageTime: serverTimestamp(),\r\n         unreadCount: {\r\n           [userId1]: 0,\r\n           [userId2]: 0\r\n         }\r\n       };\r\n \r\n+      // Only add orderId if it's defined\r\n+      if (orderId) {\r\n+        newChat.orderId = orderId;\r\n+      }\r\n+\r\n       const docRef = await addDoc(collection(this.firestore, 'chats'), newChat);\r\n       console.log('New chat created:', docRef.id);\r\n       return docRef.id;\r\n     } catch (error) {\r\n"
                },
                {
                    "date": 1763884269623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -279,22 +279,33 @@\n   }\r\n \r\n   // Get total unread count for user\r\n   async getTotalUnreadCount(userId: string): Promise<number> {\r\n-    const q = query(\r\n-      collection(this.firestore, 'chats'),\r\n-      where('participantIds', 'array-contains', userId)\r\n-    );\r\n+    try {\r\n+      const q = query(\r\n+        collection(this.firestore, 'chats'),\r\n+        where('participantIds', 'array-contains', userId)\r\n+      );\r\n \r\n-    const snapshot = await getDocs(q);\r\n-    let totalUnread = 0;\r\n+      const snapshot = await getDocs(q);\r\n+      let totalUnread = 0;\r\n \r\n-    snapshot.docs.forEach(doc => {\r\n-      const chat = doc.data() as Chat;\r\n-      totalUnread += chat.unreadCount[userId] || 0;\r\n-    });\r\n+      snapshot.docs.forEach(doc => {\r\n+        const chat = doc.data() as Chat;\r\n+        // Safely get unread count, default to 0\r\n+        const unreadCount = chat.unreadCount?.[userId] || 0;\r\n+        // Only count valid numbers greater than 0\r\n+        if (typeof unreadCount === 'number' && unreadCount > 0) {\r\n+          totalUnread += unreadCount;\r\n+        }\r\n+      });\r\n \r\n-    return totalUnread;\r\n+      console.log(`Total unread messages for ${userId}:`, totalUnread);\r\n+      return totalUnread;\r\n+    } catch (error) {\r\n+      console.error('Error getting total unread count:', error);\r\n+      return 0;\r\n+    }\r\n   }\r\n \r\n   // Get chat by ID\r\n   async getChatById(chatId: string): Promise<Chat | null> {\r\n"
                },
                {
                    "date": 1763884288117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -258,25 +258,40 @@\n   }\r\n \r\n   // Mark messages as read\r\n   async markMessagesAsRead(chatId: string, userId: string): Promise<void> {\r\n-    await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n-      [`unreadCount.${userId}`]: 0\r\n-    });\r\n+    try {\r\n+      // Reset unread count to 0\r\n+      await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n+        [`unreadCount.${userId}`]: 0\r\n+      });\r\n \r\n-    // Update all unread messages\r\n-    const q = query(\r\n-      collection(this.firestore, 'chats', chatId, 'messages'),\r\n-      where('senderId', '!=', userId),\r\n-      where('read', '==', false)\r\n-    );\r\n+      console.log(`Marked messages as read for user ${userId} in chat ${chatId}`);\r\n \r\n-    const snapshot = await getDocs(q);\r\n-    const updatePromises = snapshot.docs.map(doc => \r\n-      updateDoc(doc.ref, { read: true })\r\n-    );\r\n+      // Update all unread messages\r\n+      try {\r\n+        const q = query(\r\n+          collection(this.firestore, 'chats', chatId, 'messages'),\r\n+          where('senderId', '!=', userId),\r\n+          where('read', '==', false)\r\n+        );\r\n \r\n-    await Promise.all(updatePromises);\r\n+        const snapshot = await getDocs(q);\r\n+        console.log(`Found ${snapshot.size} unread messages to mark as read`);\r\n+        \r\n+        const updatePromises = snapshot.docs.map(doc => \r\n+          updateDoc(doc.ref, { read: true })\r\n+        );\r\n+\r\n+        await Promise.all(updatePromises);\r\n+      } catch (msgError) {\r\n+        console.warn('Could not update message read status:', msgError);\r\n+        // Don't throw error - unread count is already reset\r\n+      }\r\n+    } catch (error) {\r\n+      console.error('Error marking messages as read:', error);\r\n+      throw error;\r\n+    }\r\n   }\r\n \r\n   // Get total unread count for user\r\n   async getTotalUnreadCount(userId: string): Promise<number> {\r\n@@ -314,5 +329,47 @@\n       chatId: chatDoc.id,\r\n       ...chatDoc.data()\r\n     } as Chat : null;\r\n   }\r\n+\r\n+  // Fix incorrect unread counts (utility method)\r\n+  async fixUnreadCounts(userId: string): Promise<void> {\r\n+    try {\r\n+      const q = query(\r\n+        collection(this.firestore, 'chats'),\r\n+        where('participantIds', 'array-contains', userId)\r\n+      );\r\n+\r\n+      const snapshot = await getDocs(q);\r\n+      console.log(`Checking ${snapshot.size} chats for user ${userId}`);\r\n+\r\n+      const fixPromises = snapshot.docs.map(async (chatDoc) => {\r\n+        const chatId = chatDoc.id;\r\n+        const chat = chatDoc.data() as Chat;\r\n+        \r\n+        // Count actual unread messages\r\n+        const messagesQuery = query(\r\n+          collection(this.firestore, 'chats', chatId, 'messages'),\r\n+          where('senderId', '!=', userId),\r\n+          where('read', '==', false)\r\n+        );\r\n+        \r\n+        const messagesSnapshot = await getDocs(messagesQuery);\r\n+        const actualUnreadCount = messagesSnapshot.size;\r\n+        const currentUnreadCount = chat.unreadCount?.[userId] || 0;\r\n+\r\n+        // Update if counts don't match\r\n+        if (actualUnreadCount !== currentUnreadCount) {\r\n+          console.log(`Fixing unread count for chat ${chatId}: ${currentUnreadCount} -> ${actualUnreadCount}`);\r\n+          await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n+            [`unreadCount.${userId}`]: actualUnreadCount\r\n+          });\r\n+        }\r\n+      });\r\n+\r\n+      await Promise.all(fixPromises);\r\n+      console.log('Unread counts fixed successfully');\r\n+    } catch (error) {\r\n+      console.error('Error fixing unread counts:', error);\r\n+    }\r\n+  }\r\n }\r\n"
                },
                {
                    "date": 1763886735623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -256,8 +256,70 @@\n       };\r\n     });\r\n   }\r\n \r\n+  // Get all chats (for admin) - real-time\r\n+  getAllChats(): Observable<Chat[]> {\r\n+    return new Observable(observer => {\r\n+      let unsubscribe: (() => void) | undefined;\r\n+      let hasEmitted = false;\r\n+\r\n+      try {\r\n+        console.log('Loading all platform chats...');\r\n+        \r\n+        const q = query(collection(this.firestore, 'chats'));\r\n+\r\n+        unsubscribe = onSnapshot(q, \r\n+          (snapshot) => {\r\n+            hasEmitted = true;\r\n+            const chats = snapshot.docs.map(doc => ({\r\n+              chatId: doc.id,\r\n+              ...doc.data()\r\n+            } as Chat));\r\n+            \r\n+            // Sort by last message time\r\n+            chats.sort((a, b) => {\r\n+              const aTime = a.lastMessageTime?.seconds || 0;\r\n+              const bTime = b.lastMessageTime?.seconds || 0;\r\n+              return bTime - aTime;\r\n+            });\r\n+            \r\n+            console.log('All chats loaded:', chats.length);\r\n+            observer.next(chats);\r\n+          },\r\n+          (error) => {\r\n+            console.error('Error loading all chats:', error);\r\n+            if (!hasEmitted) {\r\n+              observer.next([]);\r\n+              hasEmitted = true;\r\n+            }\r\n+            observer.error(error);\r\n+          }\r\n+        );\r\n+        \r\n+        // Timeout fallback\r\n+        setTimeout(() => {\r\n+          if (!hasEmitted) {\r\n+            console.log('No chats loaded after 5s, emitting empty array');\r\n+            observer.next([]);\r\n+            hasEmitted = true;\r\n+          }\r\n+        }, 5000);\r\n+        \r\n+      } catch (error) {\r\n+        console.error('Error setting up all chats listener:', error);\r\n+        observer.next([]);\r\n+        observer.error(error);\r\n+      }\r\n+\r\n+      return () => {\r\n+        if (unsubscribe) {\r\n+          unsubscribe();\r\n+        }\r\n+      };\r\n+    });\r\n+  }\r\n+\r\n   // Mark messages as read\r\n   async markMessagesAsRead(chatId: string, userId: string): Promise<void> {\r\n     try {\r\n       // Reset unread count to 0\r\n"
                }
            ],
            "date": 1763384538017,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { \r\n  Firestore, \r\n  collection, \r\n  doc,\r\n  addDoc,\r\n  updateDoc,\r\n  getDoc,\r\n  getDocs,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  serverTimestamp,\r\n  onSnapshot,\r\n  increment,\r\n  arrayUnion\r\n} from '@angular/fire/firestore';\r\nimport { Chat, Message } from '../models/chat.model';\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ChatService {\r\n  constructor(private firestore: Firestore) {}\r\n\r\n  // Create or get existing chat between two users\r\n  async getOrCreateChat(\r\n    userId1: string,\r\n    userName1: string,\r\n    userId2: string,\r\n    userName2: string,\r\n    orderId?: string\r\n  ): Promise<string> {\r\n    // Check if chat already exists\r\n    const q = query(\r\n      collection(this.firestore, 'chats'),\r\n      where('participantIds', 'array-contains', userId1)\r\n    );\r\n    \r\n    const snapshot = await getDocs(q);\r\n    const existingChat = snapshot.docs.find(doc => {\r\n      const chat = doc.data() as Chat;\r\n      return chat.participantIds.includes(userId2) && \r\n             (!orderId || chat.orderId === orderId);\r\n    });\r\n\r\n    if (existingChat) {\r\n      return existingChat.id;\r\n    }\r\n\r\n    // Create new chat\r\n    const newChat: Omit<Chat, 'chatId'> = {\r\n      participantIds: [userId1, userId2],\r\n      participantNames: {\r\n        [userId1]: userName1,\r\n        [userId2]: userName2\r\n      },\r\n      orderId,\r\n      lastMessage: '',\r\n      lastMessageTime: serverTimestamp(),\r\n      unreadCount: {\r\n        [userId1]: 0,\r\n        [userId2]: 0\r\n      }\r\n    };\r\n\r\n    const docRef = await addDoc(collection(this.firestore, 'chats'), newChat);\r\n    return docRef.id;\r\n  }\r\n\r\n  // Send message\r\n  async sendMessage(\r\n    chatId: string,\r\n    senderId: string,\r\n    senderName: string,\r\n    text: string\r\n  ): Promise<void> {\r\n    // Add message to messages subcollection\r\n    const message: Omit<Message, 'messageId'> = {\r\n      chatId,\r\n      senderId,\r\n      senderName,\r\n      text,\r\n      timestamp: serverTimestamp(),\r\n      read: false\r\n    };\r\n\r\n    await addDoc(\r\n      collection(this.firestore, 'chats', chatId, 'messages'), \r\n      message\r\n    );\r\n\r\n    // Update chat with last message\r\n    const chatDoc = await getDoc(doc(this.firestore, 'chats', chatId));\r\n    const chatData = chatDoc.data() as Chat;\r\n    \r\n    // Increment unread count for other participant\r\n    const otherParticipantId = chatData.participantIds.find(id => id !== senderId);\r\n    \r\n    await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n      lastMessage: text,\r\n      lastMessageTime: serverTimestamp(),\r\n      [`unreadCount.${otherParticipantId}`]: increment(1)\r\n    });\r\n  }\r\n\r\n  // Get messages for a chat (real-time)\r\n  getMessages(chatId: string): Observable<Message[]> {\r\n    return new Observable(observer => {\r\n      try {\r\n        const q = query(\r\n          collection(this.firestore, 'chats', chatId, 'messages'),\r\n          orderBy('timestamp', 'asc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, \r\n          (snapshot) => {\r\n            const messages = snapshot.docs.map(doc => ({\r\n              messageId: doc.id,\r\n              ...doc.data()\r\n            } as Message));\r\n            observer.next(messages);\r\n          },\r\n          (error) => {\r\n            console.warn('Messages orderBy failed, using fallback...', error);\r\n            // Fallback without orderBy\r\n            const fallbackQuery = collection(this.firestore, 'chats', chatId, 'messages');\r\n            \r\n            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n              const messages = snapshot.docs.map(doc => ({\r\n                messageId: doc.id,\r\n                ...doc.data()\r\n              } as Message));\r\n              \r\n              // Sort manually by timestamp\r\n              messages.sort((a, b) => {\r\n                const aTime = a.timestamp?.seconds || 0;\r\n                const bTime = b.timestamp?.seconds || 0;\r\n                return aTime - bTime; // Ascending order\r\n              });\r\n              \r\n              observer.next(messages);\r\n            });\r\n\r\n            return () => unsubscribeFallback();\r\n          }\r\n        );\r\n\r\n        return () => unsubscribe();\r\n      } catch (error) {\r\n        console.error('Error setting up messages listener:', error);\r\n        observer.error(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Get user chats (real-time)\r\n  getUserChats(userId: string): Observable<Chat[]> {\r\n    return new Observable(observer => {\r\n      try {\r\n        const q = query(\r\n          collection(this.firestore, 'chats'),\r\n          where('participantIds', 'array-contains', userId),\r\n          orderBy('lastMessageTime', 'desc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, \r\n          (snapshot) => {\r\n            const chats = snapshot.docs.map(doc => ({\r\n              chatId: doc.id,\r\n              ...doc.data()\r\n            } as Chat));\r\n            console.log('Loaded chats:', chats.length);\r\n            observer.next(chats);\r\n          },\r\n          (error) => {\r\n            console.warn('Composite index not available, using fallback...', error);\r\n            // Fallback: Query without orderBy\r\n            const fallbackQuery = query(\r\n              collection(this.firestore, 'chats'),\r\n              where('participantIds', 'array-contains', userId)\r\n            );\r\n\r\n            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n              const chats = snapshot.docs.map(doc => ({\r\n                chatId: doc.id,\r\n                ...doc.data()\r\n              } as Chat));\r\n              \r\n              // Sort manually by lastMessageTime\r\n              chats.sort((a, b) => {\r\n                const aTime = a.lastMessageTime?.seconds || 0;\r\n                const bTime = b.lastMessageTime?.seconds || 0;\r\n                return bTime - aTime;\r\n              });\r\n              \r\n              console.log('Loaded chats (fallback):', chats.length);\r\n              observer.next(chats);\r\n            });\r\n\r\n            return () => unsubscribeFallback();\r\n          }\r\n        );\r\n\r\n        return () => unsubscribe();\r\n      } catch (error) {\r\n        console.error('Error setting up chat listener:', error);\r\n        observer.error(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Mark messages as read\r\n  async markMessagesAsRead(chatId: string, userId: string): Promise<void> {\r\n    await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n      [`unreadCount.${userId}`]: 0\r\n    });\r\n\r\n    // Update all unread messages\r\n    const q = query(\r\n      collection(this.firestore, 'chats', chatId, 'messages'),\r\n      where('senderId', '!=', userId),\r\n      where('read', '==', false)\r\n    );\r\n\r\n    const snapshot = await getDocs(q);\r\n    const updatePromises = snapshot.docs.map(doc => \r\n      updateDoc(doc.ref, { read: true })\r\n    );\r\n\r\n    await Promise.all(updatePromises);\r\n  }\r\n\r\n  // Get total unread count for user\r\n  async getTotalUnreadCount(userId: string): Promise<number> {\r\n    const q = query(\r\n      collection(this.firestore, 'chats'),\r\n      where('participantIds', 'array-contains', userId)\r\n    );\r\n\r\n    const snapshot = await getDocs(q);\r\n    let totalUnread = 0;\r\n\r\n    snapshot.docs.forEach(doc => {\r\n      const chat = doc.data() as Chat;\r\n      totalUnread += chat.unreadCount[userId] || 0;\r\n    });\r\n\r\n    return totalUnread;\r\n  }\r\n\r\n  // Get chat by ID\r\n  async getChatById(chatId: string): Promise<Chat | null> {\r\n    const chatDoc = await getDoc(doc(this.firestore, 'chats', chatId));\r\n    return chatDoc.exists() ? {\r\n      chatId: chatDoc.id,\r\n      ...chatDoc.data()\r\n    } as Chat : null;\r\n  }\r\n}\r\n"
        }
    ]
}