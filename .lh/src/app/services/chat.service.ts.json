{
    "sourceFile": "src/app/services/chat.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1763384538017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763384827106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,15 +107,17 @@\n \r\n   // Get messages for a chat (real-time)\r\n   getMessages(chatId: string): Observable<Message[]> {\r\n     return new Observable(observer => {\r\n+      let unsubscribe: (() => void) | undefined;\r\n+\r\n       try {\r\n         const q = query(\r\n           collection(this.firestore, 'chats', chatId, 'messages'),\r\n           orderBy('timestamp', 'asc')\r\n         );\r\n \r\n-        const unsubscribe = onSnapshot(q, \r\n+        unsubscribe = onSnapshot(q, \r\n           (snapshot) => {\r\n             const messages = snapshot.docs.map(doc => ({\r\n               messageId: doc.id,\r\n               ...doc.data()\r\n@@ -126,9 +128,9 @@\n             console.warn('Messages orderBy failed, using fallback...', error);\r\n             // Fallback without orderBy\r\n             const fallbackQuery = collection(this.firestore, 'chats', chatId, 'messages');\r\n             \r\n-            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n+            unsubscribe = onSnapshot(fallbackQuery, (snapshot) => {\r\n               const messages = snapshot.docs.map(doc => ({\r\n                 messageId: doc.id,\r\n                 ...doc.data()\r\n               } as Message));\r\n@@ -141,32 +143,36 @@\n               });\r\n               \r\n               observer.next(messages);\r\n             });\r\n-\r\n-            return () => unsubscribeFallback();\r\n           }\r\n         );\r\n-\r\n-        return () => unsubscribe();\r\n       } catch (error) {\r\n         console.error('Error setting up messages listener:', error);\r\n         observer.error(error);\r\n       }\r\n+\r\n+      return () => {\r\n+        if (unsubscribe) {\r\n+          unsubscribe();\r\n+        }\r\n+      };\r\n     });\r\n   }\r\n \r\n   // Get user chats (real-time)\r\n   getUserChats(userId: string): Observable<Chat[]> {\r\n     return new Observable(observer => {\r\n+      let unsubscribe: (() => void) | undefined;\r\n+\r\n       try {\r\n         const q = query(\r\n           collection(this.firestore, 'chats'),\r\n           where('participantIds', 'array-contains', userId),\r\n           orderBy('lastMessageTime', 'desc')\r\n         );\r\n \r\n-        const unsubscribe = onSnapshot(q, \r\n+        unsubscribe = onSnapshot(q, \r\n           (snapshot) => {\r\n             const chats = snapshot.docs.map(doc => ({\r\n               chatId: doc.id,\r\n               ...doc.data()\r\n@@ -181,9 +187,9 @@\n               collection(this.firestore, 'chats'),\r\n               where('participantIds', 'array-contains', userId)\r\n             );\r\n \r\n-            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n+            unsubscribe = onSnapshot(fallbackQuery, (snapshot) => {\r\n               const chats = snapshot.docs.map(doc => ({\r\n                 chatId: doc.id,\r\n                 ...doc.data()\r\n               } as Chat));\r\n@@ -197,18 +203,20 @@\n               \r\n               console.log('Loaded chats (fallback):', chats.length);\r\n               observer.next(chats);\r\n             });\r\n-\r\n-            return () => unsubscribeFallback();\r\n           }\r\n         );\r\n-\r\n-        return () => unsubscribe();\r\n       } catch (error) {\r\n         console.error('Error setting up chat listener:', error);\r\n         observer.error(error);\r\n       }\r\n+\r\n+      return () => {\r\n+        if (unsubscribe) {\r\n+          unsubscribe();\r\n+        }\r\n+      };\r\n     });\r\n   }\r\n \r\n   // Mark messages as read\r\n"
                },
                {
                    "date": 1763386695464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,57 +158,64 @@\n       };\r\n     });\r\n   }\r\n \r\n-  // Get user chats (real-time)\r\n+  // Get user chats (real-time) - OPTIMIZED with fast fallback\r\n   getUserChats(userId: string): Observable<Chat[]> {\r\n     return new Observable(observer => {\r\n       let unsubscribe: (() => void) | undefined;\r\n+      let hasEmitted = false;\r\n \r\n       try {\r\n+        console.log('Setting up chat listener for user:', userId);\r\n+        \r\n+        // Use simple query without orderBy for faster initial load\r\n         const q = query(\r\n           collection(this.firestore, 'chats'),\r\n-          where('participantIds', 'array-contains', userId),\r\n-          orderBy('lastMessageTime', 'desc')\r\n+          where('participantIds', 'array-contains', userId)\r\n         );\r\n \r\n         unsubscribe = onSnapshot(q, \r\n           (snapshot) => {\r\n+            hasEmitted = true;\r\n             const chats = snapshot.docs.map(doc => ({\r\n               chatId: doc.id,\r\n               ...doc.data()\r\n             } as Chat));\r\n-            console.log('Loaded chats:', chats.length);\r\n+            \r\n+            // Sort manually by lastMessageTime\r\n+            chats.sort((a, b) => {\r\n+              const aTime = a.lastMessageTime?.seconds || 0;\r\n+              const bTime = b.lastMessageTime?.seconds || 0;\r\n+              return bTime - aTime;\r\n+            });\r\n+            \r\n+            console.log('Chats loaded:', chats.length);\r\n             observer.next(chats);\r\n           },\r\n           (error) => {\r\n-            console.warn('Composite index not available, using fallback...', error);\r\n-            // Fallback: Query without orderBy\r\n-            const fallbackQuery = query(\r\n-              collection(this.firestore, 'chats'),\r\n-              where('participantIds', 'array-contains', userId)\r\n-            );\r\n-\r\n-            unsubscribe = onSnapshot(fallbackQuery, (snapshot) => {\r\n-              const chats = snapshot.docs.map(doc => ({\r\n-                chatId: doc.id,\r\n-                ...doc.data()\r\n-              } as Chat));\r\n-              \r\n-              // Sort manually by lastMessageTime\r\n-              chats.sort((a, b) => {\r\n-                const aTime = a.lastMessageTime?.seconds || 0;\r\n-                const bTime = b.lastMessageTime?.seconds || 0;\r\n-                return bTime - aTime;\r\n-              });\r\n-              \r\n-              console.log('Loaded chats (fallback):', chats.length);\r\n-              observer.next(chats);\r\n-            });\r\n+            console.error('Chat snapshot error:', error);\r\n+            if (!hasEmitted) {\r\n+              // Emit empty array on first error to prevent infinite loading\r\n+              observer.next([]);\r\n+              hasEmitted = true;\r\n+            }\r\n+            observer.error(error);\r\n           }\r\n         );\r\n+        \r\n+        // Emit empty array immediately if no data after 3 seconds\r\n+        setTimeout(() => {\r\n+          if (!hasEmitted) {\r\n+            console.log('No chats loaded after 3s, emitting empty array');\r\n+            observer.next([]);\r\n+            hasEmitted = true;\r\n+          }\r\n+        }, 3000);\r\n+        \r\n       } catch (error) {\r\n         console.error('Error setting up chat listener:', error);\r\n+        observer.next([]); // Emit empty array instead of error\r\n         observer.error(error);\r\n       }\r\n \r\n       return () => {\r\n"
                }
            ],
            "date": 1763384538017,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { \r\n  Firestore, \r\n  collection, \r\n  doc,\r\n  addDoc,\r\n  updateDoc,\r\n  getDoc,\r\n  getDocs,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  serverTimestamp,\r\n  onSnapshot,\r\n  increment,\r\n  arrayUnion\r\n} from '@angular/fire/firestore';\r\nimport { Chat, Message } from '../models/chat.model';\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ChatService {\r\n  constructor(private firestore: Firestore) {}\r\n\r\n  // Create or get existing chat between two users\r\n  async getOrCreateChat(\r\n    userId1: string,\r\n    userName1: string,\r\n    userId2: string,\r\n    userName2: string,\r\n    orderId?: string\r\n  ): Promise<string> {\r\n    // Check if chat already exists\r\n    const q = query(\r\n      collection(this.firestore, 'chats'),\r\n      where('participantIds', 'array-contains', userId1)\r\n    );\r\n    \r\n    const snapshot = await getDocs(q);\r\n    const existingChat = snapshot.docs.find(doc => {\r\n      const chat = doc.data() as Chat;\r\n      return chat.participantIds.includes(userId2) && \r\n             (!orderId || chat.orderId === orderId);\r\n    });\r\n\r\n    if (existingChat) {\r\n      return existingChat.id;\r\n    }\r\n\r\n    // Create new chat\r\n    const newChat: Omit<Chat, 'chatId'> = {\r\n      participantIds: [userId1, userId2],\r\n      participantNames: {\r\n        [userId1]: userName1,\r\n        [userId2]: userName2\r\n      },\r\n      orderId,\r\n      lastMessage: '',\r\n      lastMessageTime: serverTimestamp(),\r\n      unreadCount: {\r\n        [userId1]: 0,\r\n        [userId2]: 0\r\n      }\r\n    };\r\n\r\n    const docRef = await addDoc(collection(this.firestore, 'chats'), newChat);\r\n    return docRef.id;\r\n  }\r\n\r\n  // Send message\r\n  async sendMessage(\r\n    chatId: string,\r\n    senderId: string,\r\n    senderName: string,\r\n    text: string\r\n  ): Promise<void> {\r\n    // Add message to messages subcollection\r\n    const message: Omit<Message, 'messageId'> = {\r\n      chatId,\r\n      senderId,\r\n      senderName,\r\n      text,\r\n      timestamp: serverTimestamp(),\r\n      read: false\r\n    };\r\n\r\n    await addDoc(\r\n      collection(this.firestore, 'chats', chatId, 'messages'), \r\n      message\r\n    );\r\n\r\n    // Update chat with last message\r\n    const chatDoc = await getDoc(doc(this.firestore, 'chats', chatId));\r\n    const chatData = chatDoc.data() as Chat;\r\n    \r\n    // Increment unread count for other participant\r\n    const otherParticipantId = chatData.participantIds.find(id => id !== senderId);\r\n    \r\n    await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n      lastMessage: text,\r\n      lastMessageTime: serverTimestamp(),\r\n      [`unreadCount.${otherParticipantId}`]: increment(1)\r\n    });\r\n  }\r\n\r\n  // Get messages for a chat (real-time)\r\n  getMessages(chatId: string): Observable<Message[]> {\r\n    return new Observable(observer => {\r\n      try {\r\n        const q = query(\r\n          collection(this.firestore, 'chats', chatId, 'messages'),\r\n          orderBy('timestamp', 'asc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, \r\n          (snapshot) => {\r\n            const messages = snapshot.docs.map(doc => ({\r\n              messageId: doc.id,\r\n              ...doc.data()\r\n            } as Message));\r\n            observer.next(messages);\r\n          },\r\n          (error) => {\r\n            console.warn('Messages orderBy failed, using fallback...', error);\r\n            // Fallback without orderBy\r\n            const fallbackQuery = collection(this.firestore, 'chats', chatId, 'messages');\r\n            \r\n            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n              const messages = snapshot.docs.map(doc => ({\r\n                messageId: doc.id,\r\n                ...doc.data()\r\n              } as Message));\r\n              \r\n              // Sort manually by timestamp\r\n              messages.sort((a, b) => {\r\n                const aTime = a.timestamp?.seconds || 0;\r\n                const bTime = b.timestamp?.seconds || 0;\r\n                return aTime - bTime; // Ascending order\r\n              });\r\n              \r\n              observer.next(messages);\r\n            });\r\n\r\n            return () => unsubscribeFallback();\r\n          }\r\n        );\r\n\r\n        return () => unsubscribe();\r\n      } catch (error) {\r\n        console.error('Error setting up messages listener:', error);\r\n        observer.error(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Get user chats (real-time)\r\n  getUserChats(userId: string): Observable<Chat[]> {\r\n    return new Observable(observer => {\r\n      try {\r\n        const q = query(\r\n          collection(this.firestore, 'chats'),\r\n          where('participantIds', 'array-contains', userId),\r\n          orderBy('lastMessageTime', 'desc')\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(q, \r\n          (snapshot) => {\r\n            const chats = snapshot.docs.map(doc => ({\r\n              chatId: doc.id,\r\n              ...doc.data()\r\n            } as Chat));\r\n            console.log('Loaded chats:', chats.length);\r\n            observer.next(chats);\r\n          },\r\n          (error) => {\r\n            console.warn('Composite index not available, using fallback...', error);\r\n            // Fallback: Query without orderBy\r\n            const fallbackQuery = query(\r\n              collection(this.firestore, 'chats'),\r\n              where('participantIds', 'array-contains', userId)\r\n            );\r\n\r\n            const unsubscribeFallback = onSnapshot(fallbackQuery, (snapshot) => {\r\n              const chats = snapshot.docs.map(doc => ({\r\n                chatId: doc.id,\r\n                ...doc.data()\r\n              } as Chat));\r\n              \r\n              // Sort manually by lastMessageTime\r\n              chats.sort((a, b) => {\r\n                const aTime = a.lastMessageTime?.seconds || 0;\r\n                const bTime = b.lastMessageTime?.seconds || 0;\r\n                return bTime - aTime;\r\n              });\r\n              \r\n              console.log('Loaded chats (fallback):', chats.length);\r\n              observer.next(chats);\r\n            });\r\n\r\n            return () => unsubscribeFallback();\r\n          }\r\n        );\r\n\r\n        return () => unsubscribe();\r\n      } catch (error) {\r\n        console.error('Error setting up chat listener:', error);\r\n        observer.error(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Mark messages as read\r\n  async markMessagesAsRead(chatId: string, userId: string): Promise<void> {\r\n    await updateDoc(doc(this.firestore, 'chats', chatId), {\r\n      [`unreadCount.${userId}`]: 0\r\n    });\r\n\r\n    // Update all unread messages\r\n    const q = query(\r\n      collection(this.firestore, 'chats', chatId, 'messages'),\r\n      where('senderId', '!=', userId),\r\n      where('read', '==', false)\r\n    );\r\n\r\n    const snapshot = await getDocs(q);\r\n    const updatePromises = snapshot.docs.map(doc => \r\n      updateDoc(doc.ref, { read: true })\r\n    );\r\n\r\n    await Promise.all(updatePromises);\r\n  }\r\n\r\n  // Get total unread count for user\r\n  async getTotalUnreadCount(userId: string): Promise<number> {\r\n    const q = query(\r\n      collection(this.firestore, 'chats'),\r\n      where('participantIds', 'array-contains', userId)\r\n    );\r\n\r\n    const snapshot = await getDocs(q);\r\n    let totalUnread = 0;\r\n\r\n    snapshot.docs.forEach(doc => {\r\n      const chat = doc.data() as Chat;\r\n      totalUnread += chat.unreadCount[userId] || 0;\r\n    });\r\n\r\n    return totalUnread;\r\n  }\r\n\r\n  // Get chat by ID\r\n  async getChatById(chatId: string): Promise<Chat | null> {\r\n    const chatDoc = await getDoc(doc(this.firestore, 'chats', chatId));\r\n    return chatDoc.exists() ? {\r\n      chatId: chatDoc.id,\r\n      ...chatDoc.data()\r\n    } as Chat : null;\r\n  }\r\n}\r\n"
        }
    ]
}